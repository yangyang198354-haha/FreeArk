<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自由方舟能耗采集平台 - 登录</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <!-- 引入配置文件 -->
    <script src="config.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 14px;
      }
      
      .login-container {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        width: 100%;
        max-width: 400px;
      }
      
      .login-header {
        text-align: center;
        margin-bottom: 2rem;
      }
      
      .login-header h2 {
        color: #303133;
        font-size: 1.5rem;
        font-weight: 600;
      }
      
      .form-group {
        margin-bottom: 1rem;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
        color: #606266;
      }
      
      .form-group input {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #dcdfe6;
        border-radius: 4px;
        font-size: 1rem;
        transition: border-color 0.3s;
      }
      
      .form-group input:focus {
        outline: none;
        border-color: #409eff;
      }
      
      .error-message {
        color: #f56c6c;
        font-size: 0.875rem;
        margin-top: 0.5rem;
      }
      
      .login-button {
        width: 100%;
        padding: 0.75rem;
        background-color: #409eff;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 1rem;
        cursor: pointer;
        transition: background-color 0.3s;
        margin-top: 1rem;
      }
      
      .login-button:hover {
        background-color: #66b1ff;
      }
      
      .login-button:disabled {
        background-color: #a0cfff;
        cursor: not-allowed;
      }
      
      .loading-spinner {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }
      
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="login-container">
      <div class="login-header">
        <h2>自由方舟能耗采集平台登录</h2>
      </div>
      
      <form id="loginForm" onsubmit="handleLogin(event)">
        <div class="form-group">
          <label for="username">用户名</label>
          <input type="text" id="username" placeholder="请输入用户名" required>
        </div>
        
        <div class="form-group">
          <label for="password">密码</label>
          <input type="password" id="password" placeholder="请输入密码" required>
        </div>
        
        <div id="errorMessage" class="error-message" style="display: none;"></div>
        
        <button type="submit" id="loginButton" class="login-button">
          <span id="buttonText">登录</span>
          <span id="loadingSpinner" class="loading-spinner" style="display: none;"></span>
        </button>
      </form>
    </div>
    
    <script>
      // 显示错误消息
      function showError(message) {
        const errorElement = document.getElementById('errorMessage');
        errorElement.textContent = message;
        errorElement.style.display = 'block';
      }
      
      // 隐藏错误消息
      function hideError() {
        document.getElementById('errorMessage').style.display = 'none';
      }
      
      // 设置按钮加载状态
      function setButtonLoading(isLoading) {
        const button = document.getElementById('loginButton');
        const buttonText = document.getElementById('buttonText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        
        button.disabled = isLoading;
        
        if (isLoading) {
          buttonText.style.display = 'none';
          loadingSpinner.style.display = 'inline-block';
        } else {
          buttonText.style.display = 'inline';
          loadingSpinner.style.display = 'none';
        }
      }
      
      // CSRF Token管理对象
      const csrfTokenManager = {
        token: null,
        timestamp: null,
        expiry: 3600000, // 1小时过期
        
        // 获取CSRF Token函数
        getToken() {
          // 检查token是否存在且未过期
          if (this.isTokenValid()) {
            console.log('从全局内存获取有效CSRF token');
            return this.token;
          }
          
          // 作为后备，尝试从cookie获取
          const cookieParts = document.cookie.split('; ');
          for (let i = 0; i < cookieParts.length; i++) {
            const row = cookieParts[i];
            if (row.indexOf('csrftoken=') === 0) {
              const cookieValue = row.substring('csrftoken='.length);
              const decodedToken = decodeURIComponent(cookieValue);
              if (decodedToken && decodedToken.length > 20) { // 基本验证token格式
                console.log('从cookie获取CSRF token');
                // 更新全局变量和时间戳
                this.token = decodedToken;
                this.timestamp = Date.now();
                return decodedToken;
              }
            }
          }
          
          console.log('未找到有效的CSRF token，当前cookies:', document.cookie);
          return null;
        },
        
        // 设置CSRF Token函数
        setToken(token) {
          if (token && token.length > 20) { // 基本验证token格式
            this.token = token;
            this.timestamp = Date.now();
            console.log('已设置全局CSRF token');
            return true;
          }
          console.warn('无效的CSRF token格式');
          return false;
        },
        
        // 验证token是否有效
        isTokenValid() {
          if (!this.token) return false;
          if (!this.timestamp) return false;
          return (Date.now() - this.timestamp) < this.expiry;
        },
        
        // 清除token
        clearToken() {
          this.token = null;
          this.timestamp = null;
          console.log('CSRF token已清除');
        }
      };
      
      // 简化的获取函数，保持向后兼容
      function getCSRFToken() {
        return csrfTokenManager.getToken();
      }
      
      // 简化的设置函数，保持向后兼容
      function setCSRFToken(token) {
        return csrfTokenManager.setToken(token);
      }
      
      // 获取API基础URL的统一函数
      function getApiBaseUrl() {
        // 优先从配置文件获取
        const configUrl = window.API_CONFIG?.baseUrl;
        if (configUrl) {
          return configUrl.replace(/\/$/, '');
        }
        
        // 其次根据当前环境自动判断
        const currentHost = window.location.hostname;
        if (currentHost === 'localhost' || currentHost === '127.0.0.1') {
          return 'http://localhost:8000';
        }
        
        // 默认回退地址
        return 'http://192.168.31.52:8000';
      }
      
      // 确保获取CSRF Token的函数（带重试机制）
      async function ensureCSRFToken(maxRetries = 3) {
        // 先检查是否已有有效token
        if (csrfTokenManager.isTokenValid()) {
          console.log('已有有效的CSRF token，无需重新获取');
          return true;
        }
        
        let retries = 0;
        let lastError = null;
        
        while (retries < maxRetries) {
          try {
            retries++;
            console.log(`尝试获取CSRF token (第${retries}次/${maxRetries}次)`);
            
            // 获取当前token状态
            const currentToken = getCSRFToken();
            console.log('当前获取到的token:', currentToken ? '存在' : '不存在');
            console.log('请求前cookies:', document.cookie);
            
            // 使用统一的API地址获取函数
            const apiBaseUrl = getApiBaseUrl();
            console.log('使用API地址:', apiBaseUrl);
            
            // 获取当前页面的origin
            const currentOrigin = window.location.origin;
            console.log('当前页面origin:', currentOrigin);
            
            // 调用get-csrf-token端点获取CSRF token
            const response = await fetch(`${apiBaseUrl}/api/get-csrf-token/`, {
              method: 'GET',
              credentials: 'include', // 确保包含cookies
              headers: {
                'Content-Type': 'application/json',
                'Origin': currentOrigin // 设置正确的origin头
              },
              mode: 'cors', // 显式设置为cors模式
              timeout: 10000 // 10秒超时
            });
            
            // 验证响应状态
            if (!response.ok) {
              throw new Error(`HTTP错误: ${response.status}`);
            }
            
            // 检查响应头中的Set-Cookie
            let cookieSet = false;
            const responseHeaders = {};
            response.headers.forEach((value, name) => {
              responseHeaders[name] = value;
              if (name.toLowerCase() === 'set-cookie' && value.includes('csrftoken=')) {
                cookieSet = true;
                console.log('检测到Set-Cookie头中的csrftoken');
              }
            });
            
            // 解析响应体
            let responseData;
            try {
              responseData = await response.json();
            } catch (jsonError) {
              throw new Error(`无效的JSON响应: ${jsonError.message}`);
            }
            
            // 验证响应数据
            if (!responseData || typeof responseData.csrftoken !== 'string') {
              throw new Error('响应中缺少有效的csrftoken字段');
            }
            
            // 设置token到全局管理器
            const tokenSetSuccess = setCSRFToken(responseData.csrftoken);
            if (!tokenSetSuccess) {
              throw new Error('设置CSRF token失败');
            }
            
            // 延迟一下再检查cookie，确保cookie已经设置
            await new Promise(resolve => setTimeout(resolve, 100));
            console.log('请求后cookies:', document.cookie);
            
            // 尝试再次获取token验证
            const newToken = getCSRFToken();
            if (newToken) {
              console.log('成功获取并验证CSRF token');
              return true;
            } else {
              throw new Error('无法从cookie或内存中获取有效的token');
            }
          } catch (error) {
            lastError = error;
            console.error(`获取CSRF token失败 (第${retries}次):`, error.message);
            
            // 如果不是最后一次重试，等待后重试
            if (retries < maxRetries) {
              const waitTime = 1000 * retries; // 指数退避
              console.log(`等待${waitTime}ms后重试...`);
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
          }
        }
        
        // 所有重试都失败
        console.error('所有尝试获取CSRF token都失败:', lastError?.message);
        return false;
      }
      
      // 登录处理函数
      async function handleLogin(event) {
        event.preventDefault();
        
        // 输入验证
        const username = document.getElementById('username').value.trim();
        const password = document.getElementById('password').value;
        
        if (!username) {
            showError('请输入用户名');
            return;
        }
        if (!password) {
            showError('请输入密码');
            return;
        }
        
        // 设置加载状态
        setButtonLoading(true);
        hideError();
        
        try {
          console.log('开始登录流程');
          
          // 首先确保获取CSRF token，增加重试次数
          const csrfTokenObtained = await ensureCSRFToken(3);
          if (!csrfTokenObtained) {
            throw new Error('无法获取必要的安全令牌，请刷新页面重试');
          }
          
          // 获取CSRF token用于请求头
          const csrfToken = getCSRFToken();
          if (!csrfToken || csrfToken.length < 20) {
            throw new Error('未找到有效的CSRF令牌，请刷新页面重试');
          }
          
          console.log('使用CSRF token进行登录请求');
          
          // 使用统一的API地址获取函数
          const apiBaseUrl = getApiBaseUrl();
          const loginUrl = `${apiBaseUrl}/api/auth/login/`;
          
          // 执行登录请求，添加超时设置
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000); // 15秒超时
          
          try {
            const response = await fetch(loginUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
                'Accept': 'application/json'
              },
              credentials: 'include', // 确保包含cookies
              body: JSON.stringify({ username, password }),
              signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            console.log('登录请求URL:', loginUrl);
            console.log('登录请求响应状态:', response.status);
            
            // 尝试解析响应
            let data;
            try {
              data = await response.json();
              console.log('登录响应数据:', data);
            } catch (jsonError) {
              console.error('解析响应JSON失败:', jsonError);
              throw new Error('服务器返回了无效的响应格式');
            }
            
            // 登录成功
            if (response.ok && data && data.token) {
              // 验证token格式
              if (typeof data.token !== 'string' || data.token.length < 20) {
                throw new Error('服务器返回了无效的认证令牌');
              }
              
              // 安全地设置cookie
              const cookieOptions = {
                path: '/',
                maxAge: 3600,
                sameSite: 'Lax',
                secure: window.location.protocol === 'https:'
              };
              
              // 构建cookie字符串
              let cookieString = `auth_token=${encodeURIComponent(data.token)}; path=${cookieOptions.path}; max-age=${cookieOptions.maxAge}`;
              if (cookieOptions.sameSite) cookieString += `; SameSite=${cookieOptions.sameSite}`;
              if (cookieOptions.secure) cookieString += '; Secure';
              
              document.cookie = cookieString;
              console.log('Token已安全存储到cookie');
              
              // 同时设置localStorage以保持兼容性
              try {
                localStorage.setItem('userToken', data.token);
                localStorage.setItem('isAuthenticated', 'true');
                
                // 尝试保存用户信息到localStorage
                if (data.user) {
                  localStorage.setItem('userInfo', JSON.stringify(data.user));
                }
                console.log('认证信息已存储到localStorage');
              } catch (storageError) {
                console.warn('无法存储到localStorage，但不影响登录功能:', storageError);
              }
              
              // 登录成功后跳转到主页
              console.log('登录成功！正在跳转到主页...');
              setTimeout(() => {
                window.location.href = 'home.html';
              }, 500);
            } else if (data && data.detail) {
              throw new Error(data.detail);
            } else if (data && data.non_field_errors) {
              throw new Error(data.non_field_errors?.[0] || '登录失败，请检查用户名和密码');
            } else if (!response.ok) {
              // 根据不同的HTTP状态码提供更具体的错误信息
              if (response.status === 401) {
                throw new Error('用户名或密码错误');
              } else if (response.status === 429) {
                throw new Error('登录尝试过于频繁，请稍后再试');
              } else if (response.status >= 500) {
                throw new Error('服务器内部错误，请稍后再试');
              } else {
                throw new Error('登录失败，请检查用户名和密码');
              }
            } else {
              throw new Error('登录失败，请检查用户名和密码');
            }
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === 'AbortError') {
              throw new Error('登录请求超时，请检查网络连接');
            }
            throw fetchError;
          }
        } catch (error) {
          console.error('登录过程出错:', error);
          // 对错误进行分类处理，提供更友好的错误信息
          let userFriendlyMessage = error.message;
          
          if (userFriendlyMessage.includes('NetworkError')) {
            userFriendlyMessage = '网络连接异常，请检查您的网络';
          } else if (userFriendlyMessage.includes('Failed to fetch')) {
            userFriendlyMessage = '无法连接到服务器，请稍后再试';
          }
          
          showError(userFriendlyMessage);
          
          // 如果是CSRF相关错误，清除可能已损坏的token
          if (userFriendlyMessage.includes('CSRF') || userFriendlyMessage.includes('安全令牌')) {
            csrfTokenManager.clearToken();
          }
        } finally {
          setButtonLoading(false);
        }
      }
      

    </script>
  </body>
</html>